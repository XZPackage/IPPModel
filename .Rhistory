library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
xxx <- R6::R6Class(
"xxx",
public = list(A,B)
)
xxx <- R6::R6Class(
"xxx",
public = list(A=NA,B=NA)
)
x = xxx$new()
x$A
xxx <- R6::R6Class(
"xxx",
public = list(A=2,B='NA')
)
x = xxx$new()
x$A
x$B
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
update.packages(ask = FALSE, checkBuilt = TRUE)
update.packages(ask = FALSE, checkBuilt = TRUE)
install.packages("roxygen2")
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
library(IPPModel)
install.packages("roxygen2")
install.packages("knitr")
install.packages("Rtools")
install.packages("rmarkdown")
install.packages("testthat")
library(nnet)
data("bank")
# build model
bank.NN <- nnet(y ~ ., data = bank, size = 5, maxit = 1000)
# remove the output variable
bank.ds = bank[-17]
# create IPPModel object
IPP.bank = IPPModel$new(XDS=bank.ds, PredFun=bank.NN,
ModelPackage="nnet", PredType="raw", PredDim=1,
XB.Size=1000, XB.SamplingMethod="joint")
# modify the clustering method to "kmedoids"
IPP.bank$ParaTable$clusteringMethod = "kmedoids"
# execute all tasks
IPP.bank$ExecuteAll()
IPP.bank$DrawIPP(centralized = TRUE, nc = 4)
IPP.bank$DrawFIN(threshold = 0.2, lay.out = igraph::layout.auto)
IPP.bank$WriteToExcel("output.xlsx")
library(randomForest)
data("whitewine")
# build model
WW.RF <- randomForest(quality ~ ., data = whitewine, mtry = 4,importance=TRUE, na.action=na.omit)
# remove the output variable
WW.ds = whitewine[-12]
# create IPPModel object
IPP.WW = IPPModel$new(XDS=WW.ds, PredFun=WW.RF,
ModelPackage="randomForest", PredType="response", PredDim=1,
XB.Size=1000, XB.SamplingMethod="joint")
# set the maximum depth of trees to be 5
IPP.WW$ParaTable$treeDepth = 5
# execute all tasks
IPP.WW$ExecuteAll()
IPP.WW$DrawIPP(centralized = TRUE, nc = 4)
IPP.WW$DrawFIN(threshold = 0.1, lay.out = igraph::layout.circle)
library(kernlab)
data("iris")
iris.SVM <- ksvm(Species ~ ., data = iris,kernel="rbfdot", kpar="automatic",C=0.1, prob.model = TRUE)
# remove the output variable
iris.ds = iris[-5]
# create IPPModel object
IPP.iris = IPPModel$new(XDS=iris.ds, PredFun=iris.SVM,
ModelPackage="kernlab", PredType="prob", PredDim=1,
XB.Size=200, XB.SamplingMethod="independent")
# execute the tasks step by step
IPP.iris$SamplingXA()  # sampling XA
IPP.iris$SamplingXB()  # sampling XB
IPP.iris$PredictData()  # predict
IPP.iris$ClusterImpactPlots() # clustering impact plots
IPP.iris$BuildTree()  # build tree
IPP.iris$DrawIPP(centralized = TRUE, nc = 4)
IPP.iris$DrawIPP(centralized = TRUE, nc = 4)
IPP.iris$DrawFIN(threshold = 0.3, lay.out = igraph::layout.auto)
IPP.iris$DrawFIN(threshold = 0.3, lay.out = igraph::layout.auto)
IPP.iris$Clustering.Res
self = IPP.iris
fea = "Petal.Width"
IPPs = self$Clustering.Res[[fea]][["medoids"]]
if(centralized){
IPPs = IPPs - rowMeans(IPPs)
}
IPPs = self$Clustering.Res[[fea]][["medoids"]]
bestK = self$Clustering.Res[[fea]][["bestK"]]
XA = self$XA.Sample[[fea]]
bestK
XA
ymax = max(IPPs)
ymin = min(IPPs)
self$ParaTable[fea,"dataType"] == "interval"
plot(x = XA, y = IPPs[1,], type = "l", xlab = fea,
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
y = IPPs[1,]
y
IPPs
if(bestK > 1)
y = IPPs[1,]
else
y = IPPs
if(self$ParaTable[fea,"dataType"] == "interval"){
plot(x = XA, y = y, type = "l", xlab = fea,
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
}else{
plot(x = XA, y = y, type = "l", xlab = fea, xaxt = "n",
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
axis(1, labels = as.character(XA), at = as.numeric(XA))
}
if(bestK > 1)
y = IPPs[1,]
else
y = IPPs
if(bestK > 1)
y = IPPs[1,]
else
y = IPPs
if(bestK > 1){
y = IPPs[1,]
}else{
y = IPPs
}
if(self$ParaTable[fea,"dataType"] == "interval"){
plot(x = XA, y = y, type = "l", xlab = fea,
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
}else{
plot(x = XA, y = y, type = "l", xlab = fea, xaxt = "n",
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
axis(1, labels = as.character(XA), at = as.numeric(XA))
}
y
y[,1]
if(bestK > 1){
y = IPPs[1,]
}else{
y = IPPs[,1]
}
if(self$ParaTable[fea,"dataType"] == "interval"){
plot(x = XA, y = y, type = "l", xlab = fea,
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
}else{
plot(x = XA, y = y, type = "l", xlab = fea, xaxt = "n",
ylab = "prediction", ylim = c(ymin, ymax), col = self$ColorList[1])
axis(1, labels = as.character(XA), at = as.numeric(XA))
}
library(IPPModel)
IPP.iris = IPPModel$new(XDS=iris.ds, PredFun=iris.SVM,
ModelPackage="kernlab", PredType="prob", PredDim=1,
XB.Size=200, XB.SamplingMethod="independent")
# execute the tasks step by step
IPP.iris$SamplingXA()  # sampling XA
IPP.iris$SamplingXB()  # sampling XB
IPP.iris$PredictData()  # predict
IPP.iris$ClusterImpactPlots() # clustering impact plots
IPP.iris$BuildTree()  # build tree
IPP.iris$DrawIPP(centralized = TRUE, nc = 4)
IPP.iris$DrawFIN(threshold = 0.3, lay.out = igraph::layout.auto)
